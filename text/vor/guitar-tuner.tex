\section{СТВОРЕННЯ ANDROID-ДОДАТКУ "ГІТАРНИЙ ТЮНЕР"}

\addCodeAsImg{\lstinputlisting[numbers=left]{code/MapFrequencyFinder.java}}{Хеш-таблиця нот}{fig:MapFrequencyFinder}
\addCodeAsImg{\lstinputlisting[numbers=left]{code/NoteName.java}}{Перерахування нот}{fig:NoteName}
\addimg{img/perfect-tone.jpg}{0.4}{Ідеальна нота}{fig:PerfectTone}
\addimg{img/bad-note.jpg}{0.4}{Неточна нота}{fig:BadNote}

\subsection{Розробка вимог до додатку та чек-лісту тестування}

Для тестування додатку було обрано використувати саме чек-ліст, а не повноцінний тест план, тому що у розробці додатку приймав участь один розробник, і чек-ліст виступив у якості допоміжного інструмента, що пояснював би, що конкретно треба протестувати, без уточнення деталей.

\subsubsection{Вимоги до додатку}

Вимоги до додатку було представлено у вигляді так званих "user story" ("користувацьких історій"). Цей тип запису вимог є оптимальним для невеликих додатків, функціонал яких є зрозумілим на етапі ідеї, а також надання специфікації вимог саме у такому вигляді типово для невеликих команд або одного розробника. 

Було вирішено не розробляти повноцінну специфікацію за усіма вимогами IEEE 830, тому що цей додаток не є enterprise-проектом із великою кількості різнорівневої логіки. Базуючись на цьому, було створено наступні користувацькі історії у якості вимог до додатку:

\begin{enumerate}
    \item Як користувач, я хочу мати можливість бачити на екрані смартфону ноту, що прозвучала.
    \item Як користувач, я хочу мати можиливість бачити на екрані частоти ноти, що прозвучала.
    \item Як користувач, я хочу мати можливість бачити рекомендації щодо того, що потрібно зробити зі струною, яку я смикнув (натягнути сильніше чи послабити натяжіння)
    \item Як користувач, я хочу мати можливість бачити можливі інші назви ноти, що прозвучала.
    
\end{enumerate}

\subsubsection{Чек-ліст тестування}

Для мануального тестування додатку було розроблено чек-ліст, що складається з двох колонок: короткий опис тесту та статус тесту (passed/failed). У цьому чек-лісті тестами було покрито користувацький інтерфейс додатку та його функціональні можливості.

\begin{enumerate}
    \item Можливість роботи додатку на ОС Android 4.0.0+ - passed.
    \item Розпізнавання сгенерованих частот нот тональності до-мажор: C, D, E, F, G, B - passed.
    \item Розпізнавання згенерованих частот полутонів: C\#, D\#, F\#, G\# - passed.
    \item Розпізнавання частот нот, зіграних на гітарі Yamaha C40: C, D, E, F, G, B - passed.
    \item Розпізнавання частот нот, зіграних на гітарі Yamaha C40: C\#, D\#, F\#, G\# - passed.
\end{enumerate}


\subsection{Проектування та реалізація алгоритму швидкого перетворення Фур'є}

\addCodeAsImg{\lstinputlisting[numbers=left]{code/FFT.java}}{Реалізація алгоритму Кулі-Тьюкі засобами Java}{fig:fft-code}

Для розробки додатку було обрано алгоритм Кулі-Тьюкі як один з найшвидших реалізацій алгоритму швидкого перетворення Фур'є. Для цього було написано клас FFT, що має метод fft(Complex[] x) ((мал.~\ref{fig:fft-code})).

\subsection{Необхідність використання декількох потоків у додатку}

У даном додатку необхідно використовувати декілька потоків, тому що у Android головним потоком є UI, тобто графічний інтерфейс. Окрім графічного інтерфейсу нам у фоні порібно підтримувати постійно працюючими ще дві операції: зчитування інформації з мікрофону та перетворення цієї інформації. Саме тому нам потрібно використовувати 3 потоки: потік графічного інтерфейсу, потік зчитування з мікрофону та потік з виконанням перетворення Фур'є. 

У Android додатках, якщо потік графічного інтерфейсу не відповідає системі більш ніж 5 секунд, спливає повідомлення про те, що додаток не відповідає (насправді додаток просто виконує важку операцію і усі інші дії у ньому заблоковані). Саме тому завдання декомпозиції задач у різних потоках є критично важливим для Android додатку. 

Для отримання даних з потоку було створено клас CommonInformationForThreads, де членами-даними є 3 змінні: float[] bytes, Complex[] complexArray та double frequency, що оголошені як volatile - тобто змінні, що можуть одночасно використовуватися лише у одному потоці. У цьому класі зберігається інформація, що отримується з потоків та обробляється у них: масив байтів аудіосигналу розміром 4096 байт, комплексний масив результуючих даних, що були отримані у результаті перетворення Фур'є та змінна, що зберігає отриману частоту ноти. 

Також було створено клас Complex, що використувується для представлення дійсного числа у вигляді комплексного з нульовою уявною частиною. Це необхідно тому, що перетворення Фур'є оперує комплексними числами. Під час ініціалізації об'єкту класу Complex у конструктор необхідно передати два числа типу double: перше - це дійсна частина комплексного числа, друге - уявна частина комплексного числа.

\subsection{Дозвіл на використання обладнання смартфону на базі ОС Android}

Починаючи з Android 7.0+ у операційній системи змінилася система дозволів на використання фізичного обладнання смартфону. До виходу Android 7.0 усі необхідні дозволи видавалися під час інсталляції (установки) додатку на смартфон з Google Play або сторонніх ресурсів. Але починаючи з Android 7.0 система видачі дозволів відчутно змінилася. Під час розробки мобільних додатків, що потребують дозволу користувача на використання обладнання смартфону необхідно врахувати цей момент.

Для того, щоб операційна система знала про те, що додатку необхідно мати доступ до обладнання девайсу, у файл AndroidManifest.xml було додано відповідний рядок про те, що додатку необхідно використовувати обладнання системи. У додатку гітарного тюнеру для коректної роботи необхідно мати лише один дозвіл - дозвіл на використання додатком мікрофону девайсу. Це необхідно для того, щоб додаток міг отримати звуковий сигнал з оточення користувача та за допомогою перетворення Фур'є знайти найбільшу частоту ноти, що звучить.


\subsection{Отримання даних з мікрофону та знаходження найбільшої частоти ноти}

Для отримання даних з мікрофону було створено пакет recorder, де, відповідно, клас AndroidAudioRecorder, що використовується для запису інформації з мікрофону. Для того, щоб масив отриманих даних можна було одразу передати до потоку, де виконується перетворення Фур'є, розмір буферу звукового сигналу було задано як 4096 байт. 

Клас AndroidAudioConfig створений використовується для налаштування мікрофону та його подальшої повноцінної працездатності. У цьому класі задається: канал запису (моно чи стерео), формат запису, розмір буферу, джерело даних, кодування даних (імпульсно-кодова модуляція).

Для пошуку найбільшої частоти з отриманих даних після швидкого перетворення Фур'є було використано алгоритм прямого перебору. Для зберігання інформації про назви нот було обрано перелічувану структуру даних.

Перелічуваний тип даних - тип даних що складається з множини іменованих значень які називаються елементами, членами чи енумераторами типу.

У нотній нотації ми маємо 12 нот, а у переліченні - 13 (\ref{fig:NoteName}). 13 значення у переліченні це значення UNDEFINED, або "невідоме", на той випадок, якщо з якихось причин ми не можемо визначити висоту ноти, що була зчитана з даних мікрофону. 
Це тринадцяте значення є дуже важливим, адже допомагає уникнути помилок, пов'язаних із тим, що програма не може визначити знайдену ноту. У разі, коли значення ноти визначається як UNDEFINED, на екрані у користувача з'являється літера "U", що посвідчує про те, що програма не змогла визначити ноту.

Для зберігання інфомації про висоти нот було обрано структуру даних хеш-таблиця 
(асоціативний масив).

Хеш-таблиця — структура даних, що реалізує інтерфейс асоціативного масиву, а саме, вона дозволяє зберігати пари (ключ, значення) і здійснювати три операції: операцію додавання нової пари, операцію пошуку і операцію видалення за ключем.

У конструкторі класу MapFrequencyFinder ми ініціалізуємо приватну константну ("final", "фінальну") змінну що має тип хеш-таблиць із назвою ноти у якості ключу та Double значення еталонної частоти цієї ноти у якості значення (\ref{fig:MapFrequencyFinder}).



\subsection{Створення UI/UX та виведення на екран результатів}

Під час розробки користувацького інтерфейсу наголос був зроблений на те, щоб створювана програма була максимально простою та зрозумілою у використанні та максимально дружньою до користувача будь-якого рівня. Саме тому у програмі інформація про отриману ноту подана у англомовній нотації, що є стандартом серед музикантів усього світу. Також у програмі подана інформація про частоту знайденої ноти та найближчої до неї.

Для гітаристів-початківців подана інформація про те, що потрібно зробити зі струною - натягнути її сильніше (якщо знайдена нота нижча за очікувану) чи послабити її (якщо знайдена нота вища за очікувану). Це полегшує процес налаштування гітари гітаристами будь-якого рівня.


\subsubsection{Відхилення проаналізованої ноти від еталонної}

Якщо струна налаштована правильно (або достатньо близько за висотою до очікуваної), колір ноти на екрані смартфону або планшету стає зеленим (мал.~\ref{fig:PerfectTone}). 

Під нотою, що звучить або тільки що прозвучала є інформація про інші назви цієї ж ноти (їх дві). Ця інформація важлива, якщо гітара налаштовується не за стандартним налаштуванням <<мі - ля - ре - соль - сі - мі>>, а наприклад у drop D (<<пониження ре-дієз>>), де замість ноти <<мі>> на шостій струні налаштовується нота <<ре>>.

Якщо струна налаштована неправильно (або недостатньо близько за висотою до очікуваної), колір ноти на екрані смартфону або планшету стає червоним (мал.~\ref{fig:BadNote}).

На екрані з'являється прохання послабити або підтягнути струну відповідно до того, чи знайдена нота вища за еталонну, чи нижча. Також є інформація про те, яка частота ноти була зіграна користувачем программи.

Під нотою, що звучить або тільки що прозвучала є інформація про інші назви цієї ж ноти (їх дві). Ця інформація важлива, якщо гітара налаштовується не за стандартним налаштуванням "мі - ля - ре - соль - сі - мі", а наприклад у drop D ("пониження ре-дієз"), де замість ноти "мі" на шостій струні налаштовується нота "ре".

