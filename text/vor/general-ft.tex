\section{ПЕРЕТВОРЕННЯ ФУР'Є У КОНТЕКСТІ ЦИФРОВОЇ ОБРОБКИ СИГНАЛІВ}

\subsection{Витяг з музикального теоретичного матеріалу}

\subsubsection{Види нот. Октави}

\addimg{img/note.png}{0.2}{Нота}{fig:Note} 

Нота — умовний графічний знак (мал.~\ref{fig:Note}), що розташовується на нотному стані (нотоносці) та вказує висоту та відносну тривалість якого-небудь звуку (в окремих випадках також і спосіб відтворення). Слово «нота» також вживається як аналог слова «ступінь» або «звук».

Ноти бувають різної висоти та тривалості. Людина може чути велику кількість високих та низьких тонів. Високі тони відносяться до більш високого рівня, низьки - до більш низького. Різні голоса та інструменти мають різне звучання. 

Ноти можуть звучати одна за одною, або одночасно. Ноти, що звучать одночасно утворюють группу звуків, що у музиці має назву "аккорд". Аккорди можуть бути консонансними та дисснонансними. Консонансні аккорди у загальному випадку людині приємно чути, диссонансні - можуть звучати неприємно або викликати тривогу. 

Окрім висоти, ноти характеризуються назвами. Взагалі існує 12 назв різних за висотою нот: До, До-діез, Ре, Ре-діез, Мі, Фа, Фа-Діез, Соль, Соль-діез, Ля, Ля-діез, Сі, До. "Діез" - це знак альтерації, що відображає підвищення ноти на половину тону. Тон - це відстань між двома сусідніми нотами, окрім: мі та фа; сі та до - між цими нотами відстань складає 0,5 тону. Також існує поняття "бемоль" - це понижчення ноти на половину тону. Відповідно до визначення, треба додати, що до-дієз та ре-бемоль; ре-діез та мі-бемоль; фа-діез та соль-бемоль; соль-діез та ля-бемоль; ля-діез та сі-бемоль - дві ноти у кожній группі мають різні назви, але однакову частоту.

\label{octaves-info}
Відстань між двома різними нотами також можна вимірювати як різницю двох частот. У музикальній теорії це прийнято називати інтервалами. Інтервали бувають наступні: чиста прима (0 напівтонів), секунда (мала - 0,5 тону, велика - 1 тон), терція (мала - 1,5 тону, велика - 2 тони), чиста кварта (2,5 тони), тритон (3 тони), чиста квінта (3,5 тони), секста (мала - 4 тони, велика - 4,5 тони), септіма (мала - 5 тонів, велика - 5,5 тонів), чиста октава (6 тонів).  Октави, залежно від частот нот, що до них входять поділяються на: мала, велика, перша, друга, третя, четверта, пята і так далі.

\subsubsection{Частота нот у математичному сенсі}

У світі музичних інструментів, фізично великі інструменти, як правило, виробляють більш низькі тони, тоді як менші інструменти, як правило, виробляють більш високі тони. Це пояснюється тим, що великі інструменти переміщують більше повітря, ніж менші, і це забезпечує нижчу висоту нот. Ось чому маленький циліндр в флейті виробляє вищі ноти, ніж велика латунна трубка туби, і чому тонкі струни на гітарі більш високі, ніж товсті струни.

Коли справа доходить до опису тональності, потрібно знати, що кожен тон, що можна
співати або грати, має певний опис. Цей опис можно виміряти науково, і отримати чисельну величину - частоту. Це фактично вимірювання того, як швидко вібрують молекули повітря; чим швидше вібрації, тим вище нота. Ці коливання вимірюються у кількості на секунду, одиницею вимірювання є Герц. \cite{miller2005complete}

Звук - це фізичне явище, що представляє собою розповсюдження у вигляді пружних хвиль механічних коливань у твердому, рідкому або газоподібному середовиші. У вузькому сенсі під звуком мають на увазі коливання, що сприймаються органами слуху тварин.


волны бывают разные (описать какие конкретно волны бывают)

\subsubsection{Амплітуда та частота ноти}

Хвиля - це коливання, що розповсюджуються у просторі з протягом часу. Тобто, кожен звуковий сигнал, як і будь-яка хвиля, має певні характеристики у часі: частота, періодичність, амплітуда коливань.  Частота ноти це частота коливань хвилі. Кожна нота характеризується унікальною для себе частотою.

Амплітуда коливань (мал.~\ref{fig:wave-amplitude}) - це найбільше відхилення величини, яка періодично змінюється від деякого значення, умовно прийнятого за нульове. Амплітуда характеризує гучність звуку. \cite{яворський2007довідник}


\addimg{img/wave-amplitude.png}{0.8}{Амлітуда та довжина хвилі}{fig:wave-amplitude}

\subsubsection{Обертони}

\addimg{img/harmonics.png}{0.6}{Обертони}{fig:harmonics}

\addimg{img/spectre.jpg}{0.7}{Спектр звуку}{fig:spectre}


Обертони у акустиці - це призвуки, що входять до спектру музикального звуку. (мал.~\ref{fig:harmonics}). Висота обертонів вище головного тону. Існування обертонів зумовлено складною картиною коливань звучащого тіла (струни, стовпу повітря, мембрани, голосових зв'язок та ін.). Частоти обертонів відповідають частотам коливань його частин.

Обертони бувають гармонічними та негармонічними. Частоти гармонічних обертонів вище за частоти головного тону у 2,3,4,5 разів (натуральне число). Гармонічні обертони разом із головним тоном називаються гармоніками.

Спектр звуку (мал.~\ref{fig:spectre}) - це сукупність простих гармонічних хвиль, на які можно розкласти звукову хвилю. \cite{келдыш1973музыкальная}

Саме обертони зумовлють для кожної людини та музичного інструменту забарвлення голосу. Тембр — "забарвлення" звуку; одна з ознак музичного звуку, поряд з висотою, силою і тривалістю. За тембром можна розрізняти звуки однакової висоти і сили, виконані на різних інструментах, різними голосами або видобуті різними способами чи штрихами. \cite{юцевич2003музика}

\subsection{Загальні положення про цифрову обробку сигналів}

\subsubsection{Аналоговий та цифровий сигнал}

\addimg{img/analog-signal.png}{0.6}{Аналоговий сигнал}{fig:analog-signal}

\addimg{img/discrete-time-signal.png}{0.6}{Дискретний за часом сигнал}{fig:discrete-time-signal}

Термін "аналоговий" використовується для опису форми сигналу, яка є неперервною за часом і може приймати безперервний діапазон значень амплітуди. Прикладом аналогового сигналу є деяка напруга, яка може бути застосована до осцилографа, що призводить до постійного відображення функції часу.

Аналогові сигнали (мал.~\ref{fig:analog-signal}) можуть також застосовуватися до звичайного аналізатора спектру для визначення їх частотного змісту. Термін "аналоговий" пов'язаний з аналоговими комп'ютерами, що використовувалися до 1980 року. Ці комп'ютери вирішували лінійні диференціальні рівняння за допомогою підключення фізичних (електронних) диференціаторів та інтеграторів, використовуючи патч-шнури телефонного оператора старого стилю. Таким чином, безперервна напруга або струм у власному контурі аналогічна певній змінної в диференціальному рівнянні, такі як швидкість, температура, тиск повітря тощо. Тому що сучасна обробка сигналу безперервного радіосигналу з використанням резисторів, конденсаторів, операційних підсилювачів тощо не має нічого спільного з історією термінів, і термін аналог є насправді неправильним. Більш правильний термін - безперервний сигнал, обробка якого, часто називається обробкою аналогових сигналів. 
Термін дискретного за часом сигналу (мал.~\ref{fig:discrete-time-signal}) використовується для опису сигналу, незалежною часовою змінною якого є такою, що ми знаємо тільки значення сигналу на дискретних моментах у часі. Таким чином, сигнал дискретного часу не представлено безперервною формою сигналу, а представлено послідовністю значень. Крім часу квантування, дискретно-часовий сигнал квантує амплітуду сигналу. \cite{lyons2004understanding} Поза наявних точок цифровий (тобто дискретизований за часом) сигнал не визначений.

Імпульсно-кодова модуляція - це спосіб перетворення сигналу з аналового у цифровий. Майже усі види даних (відео, аудіо, телеметрія) дозволяють використання ІКМ.

При імпульсно-кодової модуляції аналоговий сигнал, що передається перетворюється в цифрову форму за допомогою трьох операцій: дискретизації за часом, квантування по амплітуді і кодування.

Для перетворення аналогового сигналу в цифровий використовується аналого-цифровий перетворювач (АЦП). АЦП через рівні проміжки часу вимірює амплітуду аналогового сигналу - отримує миттєві значення або відліки сигналу, потім перетворює отcчёти в двійкові слова.

Миттєве виміряне значення аналогового сигналу квантуется за рівнями (округляється від найближчого цілого). Число рівнів квантування, зазвичай, дорівнює або кратно цілої ступеня числа 2, наприклад, 23 = 8, 24 = 16, 25 = 32 і т. Д. Номер рівня кодується двійковими словами довжиною 3, 4, 5 і т. д. біт.

Потім вихідні слова АЦП в паралельному коді піддаються кодуванню за допомогою передачі на регістр зсуву, тактованого допоміжним генератором зсуву. На виході регістра зсуву формуються пачки кодованих імпульсів в послідовному коді. Потім пачки імпульсів передаються в канал зв'язку.

Частота відліків сигналу (або швидкість оцифровки, частота дискретизації) для виключення втрат інформації відповідно до теореми Котельникова повинна бути не менше подвоєної максимальної частоти в спектрі аналогового сигналу.
\cite{панфилов1991теория}

\subsubsection{Методи аналізу звукових сигналів}

ТЕКСТУС

\subsection{Математичний аппарат перетворення Фур'є та його види.}

ТЕКСТУС

для аналогового сигнала есть непрерывное фурье и оно ок только в математике потому что ой извините там интеграл на минус бесконечность до плюс бесконечности
а еще есть куча видов сверху

\subsubsection{Дискретизація вхідного сигналу за часом}

ТЕКСТУС
берем число отсчетов сигнала какое нравится, теорема найквиста-шеннона тут играет роль

\subsubsection{Виконання перетворення Фур'є для дискретизованого за часом сигналу}

ТЕКСТУС
как это можно сделать - погуглить


\subsection{Технології створення мобільних додатків на базі ОС Android}

\subsubsection{Існуючі фреймворки для розробки Android-додатків}

У даному розділу роздивимося найбільш поширені фреймворки для розробки Android-додатків.

Xamarin - цей фреймворк дозволяє писати код на C\#. Є кросплатформовим, тому його можна використувати для розробки під iOS та Windows. Однією з головних переваг є підтримка тестування додатку у хмарі. \cite{xamarin}

React Native дозволяє створювати мобільні додатки, використовуючи мову програмування JavaScript. Має схожу архітектуру з веб-фреймворкм React, та дозволяє створювати мобільни додатки з багатим інтерфейсом, використовуючи декларативні компоненти. \cite{react-native}

Qt Mobile це фреймворк, що дозволяє писати мобільні додатки із використанням мови програмування C++. Для написання додатків використувується середовище Qt Creator. \cite{qt-mobile}

Android SDK це набір інструментів для розробника, що створений та підтримується розробниками операційної системи Android - Google. Надає дуже широкі можливості для розробки мобільних додатків. Для програмування найбільш зручно використовувати інтегроване середовище розробки Android Studio. Мовою програмування є Java.
\cite{androiddevelopers} 

Для розробки мобільного додатку гітарного тюнеру було прийнято рішення використувати Android SDK, тому що цей фреймворк підтримується розробниками операційної системи та має широку спільноту прихильників. Також завдяки інтегровному середовищі розробки Android Studio, Android SDK дуже зручний у використанні у розробці мобільних додатків.

\subsubsection{Робота з мікрофоном у смартфоні на базі операційної системи Android}

За отримання даних з мікрофону відповідає клас android.media.AudioRecord. Він записує дані у внутрішній буфер, з якого ці дані періодично потрібно забирати.

Під час ініціалізації об'єкту класу AudioRecord потрібно у конструктор передати наступні параметри:

- джерело даних;

- частота дискретизації;

- конфігурація каналів (моно чи стерео, але стерео може працювати не на всіх 
пристроях);

- формат вхідних даних, більш відомий як кодек;

- розмір внутрішнього буферу, звідки буде зчитуватись аудіопотік.

Під час створення об'єкт намагається отримати потрібні ресурси системи, і дізнатися, вдалося це йому чи ні можно за домогою методу getState(). Для отримання даних із внутрішнього буферу використовується метод read(...), що існує у декількох варіантах:

- read(byte[] audioData, int offsetInBytes, int sizeInBytes);

- read(short[] audioData, int offsetInShorts, int sizeInShorts);

- read(ByteBuffer audioBuffer, int sizeInBytes).

Параметри це:

audioData - вихідний масив

audioBuffer	вихідний буфер

offsetInBytes / offsetInShorts	індекс, з якого почнеться запис

sizeInShorts - розмір запитуваного блоку даних, у байтах для ByteBuffer та byte[], у коротких цілих для short[].

Важливим є те, що метод read(...) блокує потік до того моменту, поки не зчитає потрібну кількість байтів. А якщо у буфері байтів буде недостатньо, то метод буде очікувати, поки вони прийдуть з мікрофону. Саме тому цей метод бажано викликати у окремому потоці.

Також, для того, щоб програма мала можливість використовувати мікрофон, потрібно попросити дозволу у користувача. Починаючи з Android 7.0 дозвіл проситься під час першого запуску програми і може бути відкликаний у будь-який момент у налаштуваннях смартфону або планшету, тому потрібно перед початком зчитування даних мікрофоном переконатися у тому, що у програми є відповідний дозвіл, а якщо його немає - то попросити цього дозволу.

У файл маніфесту потрібно додати рядок:

<uses-permission android:name="android.permission.RECORD\_AUDIO" />

для того, щоб мати можливість використовувати мікрофон або простити дозволу на це.

Для того, щоб почати запис потрібно викликати метод startRecording().

\subsection{Багатопоточність у Java \& Android}

У даному підрозділі питання багатопоточності розглядається саме у контексті мови програмування Java, тому що саме на цій мові було написано додаток, і нас цікавлять особливості багатопоточності саме у цій мові програмування.

Багатопоточна програма має у своєму складі два або більше потоків, що виконуються одночасно та працюють разом для виконання деякої задачі. Операційна система контролює використання додатком програмних ресурсів та фізичного обладнання і дозволяє потокам програми ділится даними із центральним процесором. Java для цих цілей має клас Thread, тобто, багатопоточні Java-програми об'єктно-орієнтовані. Усі багатопоточні програми демонструють непередбачувану поведінку.

Це створює нову проблему для програмістів, особливо для тих, хто створює багатопоточні програми. \cite{carver2005modern}

Коли компонент додатку запускається за умови відсутності інших працездатних компонентів, система Android запускає новий процес Linux для додатку з одним потоком виконання. За замовчуванням, усі компоненти одного додатку працюють у одному процесі і потоці, що називається "головний потік". Якщо компонент запускається при наявності процесу для цього додатку (тому що існує інший компонент додатку), тоді компонент запускається у цьому процесі і використовує той самий потік виконання. Однак, можно організувати виконання інших компонентів додатку в окремих процесах та створювати додатковий потік для будь-якого процесу.

Система Android намагається зберігати процес додатку якумога довше, але все ж змушена видаляти старі процеси, щоб відновити пам'ять для нових чи більш важливих процесів. Система розподіляє процеси за "ієрархією важливості". Процеси бувають видимі та служебні. Процеси можуть обслугововувати потреби один одного.

Коли додаток виконує інтенсивну роботу у відповідь на дії користувача, ця одиночна модель потоку може викликати погану продуктивність, якщо додаток стврений неправильно. Тобто, якщо все відбувається у потоці користувацького інтерфейсу, виконання довгочасних операцій будуть блокувати весь користувацький інтерфейс.

Коли поток заблокований, ніякі події не можуть оброблятися, включачи події зміни відображення. З точки зору користувача додаток виглядає зависшим. Гірше за це, якщо поток користувацького інтерфейсу заблокований більше ніж 5 секунд, то з'являється повідомлення "додаток не відповідає".

Набір інструментів користувацького інтерфейсу не є потокобезпечним. Тому не варто працювати з користувацьким інтерфейсом з робочого потоку. Маніпуляції з користувацьким інтерфейсом потрібно виконувати з потоку користувацього інтерфейсу. 

Таким чином існує лише два правила однопоточної моделі Android:

1. Не блокуйте потік користувацього інтерфейсу.

2. Не звертайтесь до набору інструментів користувацького інтерфейсу Android зовні потоку користувацького інтерфейсу.

Для динамічності користувацького інтерфейсу важливо не блокувати поток користувацького інтерфейсу. Для цього важкі операції потрібно виконувати у "фонових" чи  "робоочих" потоках.

Для асінхронної роботи існує метод AsyncTask. Він виконує операції блокування у робочому потоці і після цього публікує результати у потоці користувацього інтерфейсу без необхідності самостійно обробляти потоки чи обробники. \cite{androiddevelopers}

\subsubsection{Способи вирішення конфлікту між потоками}

У деяких випадках реалізовані методи можуть викликатися із декількох потоків і, відповідно, мають бути написани із збереженням потокобезпечності.

Система Android пропонує механізм взаємодії процесів (IPC) із допомогою видаленого виклику процедури (RPC), під час якого метод викликається дією чи іншим компонентом додатку, але виконується видаленно (у іншому процесі) із поверненням усіх результатів викликаючему компоненту. Це викликає розділення визову методу та його даних до рівня, зрозумілого операційній системі, передачу його з локального процесу та адресного простору видаленому процесу і адресному простору, після чого повторну збірку та поновлення виклику. Після цього повертаємі значення передаються у зворотньому напрямку. 

Для виконання IPC додаток має бути прив'язаний до служби за допомогою методу bindService(). \cite{androiddevelopers}

Стан гонки, або конкуренція - це помилка проектування багатопоточної системи чи додатку, під час якої стан системи залежить від того, у якому порядку виконуються частини коду. У научному середовищі цей термін прийнято називати невизначеність паралелізму. \cite{jonathan2005linux}

Стан гонки може виникнути, якщо два потоки обробляють одну інформацію і це ніяк не було проконтрольовано розробником, як це відбувається у додатку гітарного тюнеру, де потік користувацького інтерфейсу отримує дані зі змінної, що контролюється іншим потоком.

\subsection{Тестування Android-додатків}

Ручне тестування - це процес використання функцій та функцій програми, як кінцевий користувач, щоб перевірити, чи програмне забезпечення працює за необхідністю. При ручному тестуванні тестер вручну проводить тести на програмне забезпечення, дотримуючись набору попередньо визначених тестових випадків.

Автоматичне тестування - це використання програмного забезпечення окремо від програмного забезпечення, що використовується, для контролю виконання тестів і порівняння фактичних результатів з прогнозованими результатами. Автоматизація тестування може автоматизувати деякі повторювані, але необхідні завдання у формалізованому процесі тестування, що вже існує, або виконувати додаткове тестування, яке важко зробити вручну. \cite{huizinga2007automated}

Тестування буває функціональним та нефункціональним.
Функціональні тести базуються на функціях та особливостях, а також взаємодії з іншими системами, і можуть бути представлені на всіх рівнях тестування: компонентному та модульному, інтеграційному, системному, приймальному. Функціональні види тестування тестують зовнішню поведінку системи. Найбільш поширеними видами функціональних тестів є:

\begin{enumerate}
\item Функціональне тестування
\item Тестування безпеки
\item Тестування взаємодії
\end{enumerate}

Нефункціональне тестування описує тести, що необхідні для визначення характеристик програмного забезпечення, що можуть бути виміряні різними величинами. У цілому, це тестування того, "як" система працює. Далі перераховані основні види нефункціональних тестів.

Тестування продуктивності:

\begin{enumerate}
\item Навантажувальне тестування - як програма себе поведе під високим навантаженням.
\item Стресове тестування - як програма поведе себе у стресових ситуаціях.
\item Тестування стабільності та надійності
\item Об'ємне тестування - тестування поведінки програми за великої кількості зберіганої та оброблюваної одночасно інформації.
\item Тестування установки - перевірка програми на коректність установки.
\item Тестування зручності використання - перевірка зручності користувацього інтерфейсу.
\item Тестування на відмову і відновлення - поведінка програми після відновлення у випадку, коли вона відмовила.
\end{enumerate}

Після проведення необхідних змін, таких як виправлення багу/дефекту (описать разницу), програмне забезпечення повинно бути перетестоване для підтвердження того тесту, що проблема була дійсно вирішена. Види тестування, що необхідно проводити після установки програмного забезпечення, для підтвердження працездатності додатку або правильності виправлення дефекту:

\begin{enumerate}
    \item Димове тестування - перевірка того, що основні функції програми відображаються коректно
    \item Регресійне тестування - перевірка того, що після змін нова функціональність не конфліктує зі старою.
    \item Санітарне тестування - перевірка того, що основні функції програми відображаються коректно з новою функціональністю.
\end{enumerate} 

Тест-план - документація, що описує цілі випробувань, що мають бути досягнуті, та засоби та графік їх досягнення, організовані для координації діяльності з тестування.

Тестування на основі контрольного списку - метод тестування на основі досвіду, за допомогою якого досвідчений тестер використовує перелік високого рівня елементів, який потрібно відзначити, перевірити або запам'ятати, або набір правил або критеріїв, на основі яких має бути перевірено продукт. \cite{istqb}

