\section{ПЕРЕТВОРЕННЯ ФУР'Є У КОНТЕКСТІ ЦИФРОВОЇ ОБРОБКИ СИГНАЛІВ}

\subsection{Витяг з музикального теоретичного матеріалу}

\subsubsection{Види нот. Октави}

\addimg{img/note.png}{0.2}{Нота}{fig:Note} 

Нота — умовний графічний знак (мал.~\ref{fig:Note}), що розташовується на нотному стані (нотоносці) та вказує висоту та відносну тривалість якого-небудь звуку (в окремих випадках також і спосіб відтворення). Слово «нота» також вживається як аналог слова «ступінь» або «звук».

Ноти бувають різної висоти та тривалості. Людина може чути велику кількість високих та низьких тонів. Високі тони відносяться до більш високого рівня, низькі - до більш низького. Різні голоса та інструменти мають різне звучання. 

Ноти можуть звучати одна за одною, або одночасно. Ноти, що звучать одночасно утворюють группу звуків, що у музиці має назву "аккорд". Аккорди можуть бути консонансними та дисснонансними. Консонансні аккорди у загальному випадку людині приємно чути, диссонансні - можуть звучати неприємно або викликати тривогу. 

Окрім висоти, ноти характеризуються назвами. Взагалі існує 12 назв різних за висотою нот: До, До-діез, Ре, Ре-діез, Мі, Фа, Фа-Діез, Соль, Соль-діез, Ля, Ля-діез, Сі, До. "Діез" - це знак альтерації, що відображає підвищення ноти на половину тону. Тон - це відстань між двома сусідніми нотами, окрім: мі та фа; сі та до - між цими нотами відстань складає 0,5 тону. Також існує поняття "бемоль" - це понижчення ноти на половину тону. Відповідно до визначення, треба додати, що до-дієз та ре-бемоль; ре-діез та мі-бемоль; фа-діез та соль-бемоль; соль-діез та ля-бемоль; ля-діез та сі-бемоль - дві ноти у кожній группі мають різні назви, але однакову частоту.

\label{octaves-info}
Відстань між двома різними нотами також можна вимірювати як різницю двох частот. У музикальній теорії це прийнято називати інтервалами. Інтервали бувають наступні: чиста прима (0 напівтонів), секунда (мала - 0,5 тону, велика - 1 тон), терція (мала - 1,5 тону, велика - 2 тони), чиста кварта (2,5 тони), тритон (3 тони), чиста квінта (3,5 тони), секста (мала - 4 тони, велика - 4,5 тони), септіма (мала - 5 тонів, велика - 5,5 тонів), чиста октава (6 тонів).  Октави, залежно від частот нот, що до них входять поділяються на: мала, велика, перша, друга, третя, четверта, пята і так далі.

\subsubsection{Частота нот у математичному сенсі}

У світі музичних інструментів, фізично великі інструменти, як правило, виробляють більш низькі тони, тоді як менші інструменти, як правило, виробляють більш високі тони. Це пояснюється тим, що великі інструменти переміщують більше повітря, ніж менші, і це забезпечує нижчу висоту нот. Ось чому маленький циліндр в флейті виробляє вищі ноти, ніж велика латунна трубка туби, і чому тонкі струни на гітарі більш високі, ніж товсті струни.

Коли справа доходить до опису тональності, потрібно знати, що кожен тон, що можна
співати або грати, має певний опис. Цей опис можно виміряти науково, і отримати чисельну величину - частоту. Це фактично вимірювання того, як швидко вібрують молекули повітря; чим швидше вібрації, тим вище нота. Ці коливання вимірюються у кількості на секунду, одиницею вимірювання є Герц \cite{miller2005complete}.

Звук - це фізичне явище, що представляє собою розповсюдження у вигляді пружних хвиль механічних коливань у твердому, рідкому або газоподібному середовиші. У вузькому сенсі під звуком мають на увазі коливання, що сприймаються органами слуху тварин.

\subsubsection{Амплітуда та частота ноти}

Хвиля - це коливання, що розповсюджуються у просторі з протягом часу. Тобто, кожен звуковий сигнал, як і будь-яка хвиля, має певні характеристики у часі: частота, періодичність, амплітуда коливань.  Частота ноти це частота коливань хвилі. Кожна нота характеризується унікальною для себе частотою.

Амплітуда коливань (мал.~\ref{fig:wave-amplitude}) - це найбільше відхилення величини, яка періодично змінюється від деякого значення, умовно прийнятого за нульове. Амплітуда характеризує гучність звуку \cite{яворський2007довідник}.


\addimg{img/wave-amplitude.png}{0.8}{Амлітуда та довжина хвилі}{fig:wave-amplitude}

\subsubsection{Обертони}

\addimg{img/harmonics.png}{0.6}{Обертони}{fig:harmonics}

\addimg{img/spectre.jpg}{0.7}{Спектр звуку}{fig:spectre}


Обертони у акустиці - це призвуки, що входять до спектру музикального звуку. (мал.~\ref{fig:harmonics}). Висота обертонів вище головного тону. Існування обертонів зумовлено складною картиною коливань звучащого тіла (струни, стовпу повітря, мембрани, голосових зв'язок та ін.). Частоти обертонів відповідають частотам коливань його частин.

Обертони бувають гармонічними та негармонічними. Частоти гармонічних обертонів вище за частоти головного тону у 2,3,4,5 разів (натуральне число). Гармонічні обертони разом із головним тоном називаються гармоніками.

Спектр звуку (мал.~\ref{fig:spectre}) - це сукупність простих гармонічних хвиль, на які можно розкласти звукову хвилю. \cite{келдыш1973музыкальная}

Саме обертони зумовлють для кожної людини та музичного інструменту забарвлення голосу. Тембр — "забарвлення" звуку; одна з ознак музичного звуку, поряд з висотою, силою і тривалістю. За тембром можна розрізняти звуки однакової висоти і сили, виконані на різних інструментах, різними голосами або видобуті різними способами чи штрихами. \cite{юцевич2003музика}

\subsection{Загальні положення про цифрову обробку сигналів}

\subsubsection{Аналоговий та цифровий сигнал}

\addimg{img/analog-signal.png}{0.6}{Аналоговий сигнал}{fig:analog-signal}

\addimg{img/discrete-time-signal.png}{0.6}{Дискретний за часом сигнал}{fig:discrete-time-signal}

Термін "аналоговий" використовується для опису форми сигналу, яка є неперервною за часом і може приймати безперервний діапазон значень амплітуди. Прикладом аналогового сигналу є деяка напруга, яка може бути застосована до осцилографа, що призводить до постійного відображення функції часу.

Аналогові сигнали (мал.~\ref{fig:analog-signal}) можуть також застосовуватися до звичайного аналізатора спектру для визначення їх частотного змісту. Термін "аналоговий" пов'язаний з аналоговими комп'ютерами, що використовувалися до 1980 року. Ці комп'ютери вирішували лінійні диференціальні рівняння за допомогою підключення фізичних (електронних) диференціаторів та інтеграторів, використовуючи патч-шнури телефонного оператора старого стилю. Таким чином, безперервна напруга або струм у власному контурі аналогічна певній змінної в диференціальному рівнянні, такі як швидкість, температура, тиск повітря тощо. Тому що сучасна обробка сигналу безперервного радіосигналу з використанням резисторів, конденсаторів, операційних підсилювачів тощо не має нічого спільного з історією термінів, і термін аналог є насправді неправильним. Більш правильний термін - безперервний сигнал, обробка якого, часто називається обробкою аналогових сигналів. 
Термін дискретного за часом сигналу (мал.~\ref{fig:discrete-time-signal}) використовується для опису сигналу, незалежною часовою змінною якого є такою, що ми знаємо тільки значення сигналу на дискретних моментах у часі. Таким чином, сигнал дискретного часу не представлено безперервною формою сигналу, а представлено послідовністю значень. Крім часу квантування, дискретно-часовий сигнал квантує амплітуду сигналу. \cite{lyons2004understanding} Поза наявних точок цифровий (тобто дискретизований за часом) сигнал не визначений.

Імпульсно-кодова модуляція - це спосіб перетворення сигналу з аналового у цифровий. Майже усі види даних (відео, аудіо, телеметрія) дозволяють використання ІКМ.

При імпульсно-кодової модуляції аналоговий сигнал, що передається перетворюється в цифрову форму за допомогою трьох операцій: дискретизації за часом, квантування по амплітуді і кодування.

Для перетворення аналогового сигналу в цифровий використовується аналого-цифровий перетворювач (АЦП). АЦП через рівні проміжки часу вимірює амплітуду аналогового сигналу - отримує миттєві значення або відліки сигналу, потім перетворює отcчёти в двійкові слова.

Миттєве виміряне значення аналогового сигналу квантуется за рівнями (округляється від найближчого цілого). Число рівнів квантування, зазвичай, дорівнює або кратно цілої ступеня числа 2, наприклад, 23 = 8, 24 = 16, 25 = 32 і т. Д. Номер рівня кодується двійковими словами довжиною 3, 4, 5 і т. д. біт.

Потім вихідні слова АЦП в паралельному коді піддаються кодуванню за допомогою передачі на регістр зсуву, тактованого допоміжним генератором зсуву. На виході регістра зсуву формуються пачки кодованих імпульсів в послідовному коді. Потім пачки імпульсів передаються в канал зв'язку.

Частота відліків сигналу (або швидкість оцифровки, частота дискретизації) для виключення втрат інформації відповідно до теореми Котельникова повинна бути не менше подвоєної максимальної частоти в спектрі аналогового сигналу \cite{панфилов1991теория}.

\subsection{Математичний аппарат перетворення Фур'є та його види.}

Перетворення Фур'є це лінійний оператор. Цей оператор декомпозує сигнал на його складові частоти. Термін перетворення Фур'є відноситься як до представлення частотної області функції, що залежить від часу , так і до математичної операції, яка зв'язує представлення частотної області з функцією часу. Перетворення Фур'є не обмежується функціями часу. Існує також зворотне перетворення Фур'є, яке математично синтезує вихідну функцію (часу) з її частотної області.

Лінійні операції, що виконуються в одному інтервалі (час або частота), мають відповідні операції в іншому інтервалі, які іноді легше виконувати. Операція диференціювання у часовій області відповідає множенню на частоту, так що деякі диференціальні рівняння легше аналізувати в частотній області.

Функції, локалізовані у часовій області, мають перетворення Фур'є, що розподілене у частотній області, і навпаки - явище, відоме як принцип невизначеності. Перетворення Фур'є може бути формально визначено як невідповідний інтеграл Рімана, що робить його інтегральним перетворенням, хоча це визначення не підходить для багатьох застосувань, що вимагають більш складних теорій інтеграції. Взагалі, функції, до яких застосовані методи Фур'є, є комплексними і, можливо, векторнозначними. Перетворення Фур'є додатково включає дискретне перетворення Фур'є, дискретне перетворення Фур'є і ряд Фур'є або кругове перетворення Фур'є (група = S1, одиниця кола ≈ закритий кінцевий інтервал з виявленими кінцевими точками). \cite{bailey1994fast}

Неперервне перетворення Фур'є задовільняє вимоги абстрактних математичних завдань, і орієнтоване на аналіз безперервного (аналового сигналу). Але у задач програмування безперервний аналіз сигналу у кожній можливий точці на данному етапу розвитку людства є неможливим. Саме тому було створено дискретне перетворення Фур'є, що використовується для аналізу дискретизованого за часом сигналу. Також існує віконне перетворення Фур'є та швидке перетворення Фур'є.

\subsubsection{Дискретизація вхідного сигналу за часом}

\addimg{img/q-error.png}{0.4}{Помилка квантування}{fig:q-error}

Для дискретизації неперервного за часом сигналу потрібно взять деяку кількість відліків цього сигналу. Кількість відліків може бути будь-якою і вар'юється в залежності від поставленої задачі. При дискретизації вхідного сигналу може виявитися, що отриманий набір дискретних значень не відповідає вихідному сигналу. Така ситуація називаєься помилкою квантування (мал.~\ref{fig:q-error}). 

Остаточний сигнал, що вийшов внаслідок дискретизації, можна розглядати як суму початкового сигналу і сигналу похибки (Це еквівалентно тому, що помилка є різниця між вихідним сигналом і сигналом, що вийшов в результаті дискретизації) Хоча спочатку це може здатися неочевидним, даний сигнал похибки зазвичай абсолютно випадковий. Для того, щоб зменшити похибку квантування, можно скористатися теоремою Найквіста-Шеннона (теорема Котельнікова) каже про те, що:

"Для того, щоб відновити сигнал за його відліками без втрат, необхідно, щоб частота дискретизації була хоча б у два рази більша за максимальну частоту первинного неперервного сигналу." \cite{shannon1949communities}

\subsubsection{Виконання перетворення Фур'є для дискретизованого за часом сигналу}

\addimg{img/fft-ct.png}{0.8}{Алгоритм для 8 точок}{fig:fft-ct}

Для виконання цієї задачі було обрано алгоритм швидкого перетворення Фур'є Кулі-Тьюкі (мал.~\ref{fig:fft-ct}). Цей алгоритм має складність O(N log N) та є одним з найшвидкіших реалізацій алгоритму швидкого перетворення Фур'є.

Алгоритм Кулі-Тьюкі розбиває вектор, що буде оброблений дискретним перетворенням Фур'є на менші вектори, і він може бути об'єднаний довільно з будь-яким іншим алгоритмом для дискретного перетворення Фур'є. 

Швидке перетворення Фур'є з децимацією в часі (ДВЧ) з системою радікс-2 є найпростішою і найпоширенішою формою алгоритму Кулі-Тьюкі, хоча високооптимізовані реалізації Кулі-Тьюкі зазвичай використовують інші форми алгоритму.
Radix-2 ДВЧ поділяє дискретне перетворення Фур'є розміру N на два перемежених дискретних перетворення Фур'є (звідси і назва "radix-2") розміром N / 2 з кожним рекурсивним етапом.

Дискретне перетворення Фур'є (ДПФ) визначається за формулою:

\begin{equation}
X_k = \sum_{n=0}^{N-1} x_{n}e^{{-\frac{2\pi i}{N}}nk}
\end{equation}


Де k це ціле розміром від 0 до N - 1.

Radix-2 ДВЧ спочатку обчислює дискретне перетворення Фур'є з парних індексів ($x_{2_m} = x_0, x_2, ..., x_N-2$), а потім - для непарних індексів ($x_m = x_1, x_3, ..., x_N-1$) і потім об'єднує результати для отримання повної послідовності дискретного перетворення Фур'є. 

Ця ідея може бути виконана рекурсивно для зменшення загального часу виконання до O (N log N). Ця спрощена форма передбачає, що N - ступінь 2; оскільки кількість точок N вибірки зазвичай можна вибирати вільно за допомогою програми, це часто не є важливим обмеженням (і воно також може бути вирішене за допомогою, наприклад, нульового заповнення).

Алгоритм ДВЧ з системою radix-2 переставляє ДПФ функції $x_n$ на дві частини: суму над парними індексами $n = 2m$ і суму над непарними індексами $n = 2m + 1$:

\begin{equation}
X_k = \sum_{m=0}^{N/2-1} x_{2m}e^{{-\frac{2\pi i}{N}}(2m)k} + x_{2m+1}e^{{-\frac{2\pi i}{N}}(2m+1)k}
\end{equation}

Можна обчислити загальний множник скрин 3 у другу суму, як показано в рівнянні нижче. Тоді зрозуміло, що дві суми - це ДПФ парної частини $x_ 2m$, а ДПФ непарної частини $x_(2m + 1)$ функції $x_n$. Позначимо ДПФ парних індексованих входів $x_2m$ на $E_k$ і ДПФ непарних входів $x_{2m + 1}$ на $O_k$ і отримуємо:

\begin{matrix} X_k= \underbrace{\sum \limits_{m=0}^{N/2-1} x_{2m}   e^{-\frac{2\pi i}{N/2} mk}}_{\mathrm{DFT\;of\;even-indexed\;part\;of\;} x_n} {} +  e^{-\frac{2\pi i}{N}k}
 \underbrace{\sum \limits_{m=0}^{N/2-1} x_{2m+1} e^{-\frac{2\pi i}{N/2} mk}}_{\mathrm{DFT\;of\;odd-indexed\;part\;of\;} x_n} \\ =  E_k + e^{-\frac{2\pi i}{N}k} O_k.
\end{matrix}

Завдяки періодичності комплексної експоненти $X_{k+\frac{N}{2}}$ також отримано з $E_k$ та $O_k$:

\begin{align}
X_{k + \frac{N}{2}} & =  \sum \limits_{m=0}^{N/2-1} x_{2m}   e^{-\frac{2\pi i}{N/2} m(k + \frac{N}{2})} +  e^{-\frac{2\pi i}{N}(k + \frac{N}{2})}
 \sum \limits_{m=0}^{N/2-1} x_{2m+1} e^{-\frac{2\pi i}{N/2} m(k + \frac{N}{2} )} \\
 & =  \sum \limits_{m=0}^{N/2-1} x_{2m}   e^{-\frac{2\pi i}{N/2} mk} e^{-2\pi m i} +  e^{-\frac{2\pi i}{N}k}e^{-\pi i}
 \sum \limits_{m=0}^{N/2-1} x_{2m+1} e^{-\frac{2\pi i}{N/2} mk} e^{-2\pi m i} \\
 & =  \sum \limits_{m=0}^{N/2-1} x_{2m}   e^{-\frac{2\pi i}{N/2} mk} - e^{-\frac{2\pi i}{N}k}
 \sum \limits_{m=0}^{N/2-1} x_{2m+1} e^{-\frac{2\pi i}{N/2} mk} \\
& =  E_k - e^{-\frac{2\pi i}{N}k} O_k
\end{align}

Ми можемо переписати $X_k$  як:

\begin{equation}
\begin{matrix}
X_k & =
& E_k + e^{-\frac{2\pi i}{N}k} O_k \\
X_{k+\frac{N}{2}} & =
& E_k - e^{-\frac{2\pi i}{N}{k}} O_k
\end{matrix}
\end{equation}




Цей результат, що виражає ДПФ довжини N рекурсивно в термінах двох ДПФ розміром N / 2, це суть radix-2 ДВЧ швидкого перетворення Фур'є. Алгоритм є швидким завдяки повторному використанню результатів проміжних обчислень для обчислення декількох виходів ДПФ. Зауважимо, що кінцеві виходи отримуються комбінацією $E_k$ та $O_k \exp(-2\pi i k/N)$, який є просто ДПФ розміром 2 (іноді його називають метеликом); коли це узагальнено на великі розміри нижче, ДПФ розміру-2 замінюється більшим ДПФ (який сам може бути оцінений за допомогою швидкого перетворення Фур'є).

\subsection{Робота з мікрофоном у смартфоні на базі ОС Android}

За отримання даних з мікрофону відповідає клас android.media.AudioRecord. Він записує дані у внутрішній буфер, з якого ці дані періодично потрібно забирати. Під час ініціалізації об'єкту класу AudioRecord потрібно у конструктор передати наступні параметри:

- джерело даних;

- частота дискретизації;

- конфігурація каналів (моно чи стерео, але стерео може працювати не на всіх 
пристроях);

- формат вхідних даних, більш відомий як кодек;

- розмір внутрішнього буферу, звідки буде зчитуватись аудіопотік.

Під час створення об'єкт намагається отримати потрібні ресурси системи, і дізнатися, вдалося це йому чи ні можно за домогою методу getState(). Для отримання даних із внутрішнього буферу використовується метод read(...), що існує у декількох варіантах:

- read(byte[] audioData, int offsetInBytes, int sizeInBytes);

- read(short[] audioData, int offsetInShorts, int sizeInShorts);

- read(ByteBuffer audioBuffer, int sizeInBytes).

Параметри це:

audioData - вихідний масив

audioBuffer	вихідний буфер

offsetInBytes / offsetInShorts	індекс, з якого почнеться запис

sizeInShorts - розмір запитуваного блоку даних, у байтах для ByteBuffer та byte[], у коротких цілих для short[].

Важливим є те, що метод read(...) блокує потік до того моменту, поки не зчитає потрібну кількість байтів. А якщо у буфері байтів буде недостатньо, то метод буде очікувати, поки вони прийдуть з мікрофону. Саме тому цей метод бажано викликати у окремому потоці.

Також, для того, щоб програма мала можливість використовувати мікрофон, потрібно попросити дозволу у користувача. Починаючи з Android 7.0 дозвіл проситься під час першого запуску програми і може бути відкликаний у будь-який момент у налаштуваннях смартфону або планшету, тому потрібно перед початком зчитування даних мікрофоном переконатися у тому, що у програми є відповідний дозвіл, а якщо його немає - то попросити цього дозволу.

У файл маніфесту потрібно додати рядок:

<uses-permission android:name="android.permission.RECORD\_AUDIO" />

для того, щоб мати можливість використовувати мікрофон або простити дозволу на це.

Для того, щоб почати запис потрібно викликати метод startRecording().

\subsection{Багатопоточність у Java \& Android}

У даному підрозділі питання багатопоточності розглядається саме у контексті мови програмування Java, тому що саме на цій мові було написано додаток, і нас цікавлять особливості багатопоточності саме у цій мові програмування.

Багатопоточна програма має у своєму складі два або більше потоків, що виконуються одночасно та працюють разом для виконання деякої задачі. Операційна система контролює використання додатком програмних ресурсів та фізичного обладнання і дозволяє потокам програми ділится даними із центральним процесором. Java для цих цілей має клас Thread, тобто, багатопоточні Java-програми об'єктно-орієнтовані. Усі багатопоточні програми демонструють непередбачувану поведінку.

Це створює нову проблему для програмістів, особливо для тих, хто створює багатопоточні програми. \cite{carver2005modern}

Коли компонент додатку запускається за умови відсутності інших працездатних компонентів, система Android запускає новий процес Linux для додатку з одним потоком виконання. За замовчуванням, усі компоненти одного додатку працюють у одному процесі і потоці, що називається "головний потік". Якщо компонент запускається при наявності процесу для цього додатку (тому що існує інший компонент додатку), тоді компонент запускається у цьому процесі і використовує той самий потік виконання. Однак, можно організувати виконання інших компонентів додатку в окремих процесах та створювати додатковий потік для будь-якого процесу.

Система Android намагається зберігати процес додатку якумога довше, але все ж змушена видаляти старі процеси, щоб відновити пам'ять для нових чи більш важливих процесів. Система розподіляє процеси за "ієрархією важливості". Процеси бувають видимі та служебні. Процеси можуть обслугововувати потреби один одного.

Коли додаток виконує інтенсивну роботу у відповідь на дії користувача, ця одиночна модель потоку може викликати погану продуктивність, якщо додаток стврений неправильно. Тобто, якщо все відбувається у потоці користувацького інтерфейсу, виконання довгочасних операцій будуть блокувати весь користувацький інтерфейс.

Коли поток заблокований, ніякі події не можуть оброблятися, включачи події зміни відображення. З точки зору користувача додаток виглядає зависшим. Гірше за це, якщо поток користувацького інтерфейсу заблокований більше ніж 5 секунд, то з'являється повідомлення <<додаток не відповідає>>.

Набір інструментів користувацького інтерфейсу не є потокобезпечним. Тому не варто працювати з користувацьким інтерфейсом з робочого потоку. Маніпуляції з користувацьким інтерфейсом потрібно виконувати з потоку користувацього інтерфейсу. 

Таким чином існує лише два правила однопоточної моделі Android:

1. Не блокуйте потік користувацього інтерфейсу.

2. Не звертайтесь до набору інструментів користувацького інтерфейсу Android зовні потоку користувацького інтерфейсу.

Для динамічності користувацького інтерфейсу важливо не блокувати поток користувацького інтерфейсу. Для цього важкі операції потрібно виконувати у "фонових" чи  "робоочих" потоках.

Для асінхронної роботи існує метод AsyncTask. Він виконує операції блокування у робочому потоці і після цього публікує результати у потоці користувацього інтерфейсу без необхідності самостійно обробляти потоки чи обробники. \cite{androiddevelopers}

\subsubsection{Способи вирішення конфлікту між потоками}

У деяких випадках реалізовані методи можуть викликатися із декількох потоків і, відповідно, мають бути написани із збереженням потокобезпечності.

Система Android пропонує механізм взаємодії процесів (IPC) із допомогою видаленого виклику процедури (RPC), під час якого метод викликається дією чи іншим компонентом додатку, але виконується видаленно (у іншому процесі) із поверненням усіх результатів викликаючему компоненту. Це викликає розділення визову методу та його даних до рівня, зрозумілого операційній системі, передачу його з локального процесу та адресного простору видаленому процесу і адресному простору, після чого повторну збірку та поновлення виклику. Після цього повертаємі значення передаються у зворотньому напрямку. 

Для виконання IPC додаток має бути прив'язаний до служби за допомогою методу bindService(). \cite{androiddevelopers}

Стан гонки, або конкуренція - це помилка проектування багатопоточної системи чи додатку, під час якої стан системи залежить від того, у якому порядку виконуються частини коду. У научному середовищі цей термін прийнято називати невизначеність паралелізму. \cite{jonathan2005linux}

Стан гонки може виникнути, якщо два потоки обробляють одну інформацію і це ніяк не було проконтрольовано розробником, як це відбувається у додатку гітарного тюнеру, де потік користувацького інтерфейсу отримує дані зі змінної, що контролюється іншим потоком.

\subsection{Тестування Android-додатків}

Ручне тестування - це процес використання функцій та функцій програми, як кінцевий користувач, щоб перевірити, чи програмне забезпечення працює за необхідністю. При ручному тестуванні тестер вручну проводить тести на програмне забезпечення, дотримуючись набору попередньо визначених тестових випадків.

Автоматичне тестування - це використання програмного забезпечення окремо від програмного забезпечення, що використовується, для контролю виконання тестів і порівняння фактичних результатів з прогнозованими результатами. Автоматизація тестування може автоматизувати деякі повторювані, але необхідні завдання у формалізованому процесі тестування, що вже існує, або виконувати додаткове тестування, яке важко зробити вручну. \cite{huizinga2007automated}

Тестування буває функціональним та нефункціональним.
Функціональні тести базуються на функціях та особливостях, а також взаємодії з іншими системами, і можуть бути представлені на всіх рівнях тестування: компонентному та модульному, інтеграційному, системному, приймальному. Функціональні види тестування тестують зовнішню поведінку системи. Найбільш поширеними видами функціональних тестів є:

\begin{enumerate}
\item Функціональне тестування
\item Тестування безпеки
\item Тестування взаємодії
\end{enumerate}

Нефункціональне тестування описує тести, що необхідні для визначення характеристик програмного забезпечення, що можуть бути виміряні різними величинами. У цілому, це тестування того, "як" система працює. Далі перераховані основні види нефункціональних тестів.

Тестування продуктивності:

\begin{enumerate}
\item Навантажувальне тестування - як програма себе поведе під високим навантаженням.
\item Стресове тестування - як програма поведе себе у стресових ситуаціях.
\item Тестування стабільності та надійності
\item Об'ємне тестування - тестування поведінки програми за великої кількості зберіганої та оброблюваної одночасно інформації.
\item Тестування установки - перевірка програми на коректність установки.
\item Тестування зручності використання - перевірка зручності користувацього інтерфейсу.
\item Тестування на відмову і відновлення - поведінка програми після відновлення у випадку, коли вона відмовила.
\end{enumerate}

Після проведення необхідних змін, таких як виправлення багу/дефекту (описать разницу), програмне забезпечення повинно бути перетестоване для підтвердження того тесту, що проблема була дійсно вирішена. Види тестування, що необхідно проводити після установки програмного забезпечення, для підтвердження працездатності додатку або правильності виправлення дефекту:

\begin{enumerate}
    \item Димове тестування - перевірка того, що основні функції програми відображаються коректно
    \item Регресійне тестування - перевірка того, що після змін нова функціональність не конфліктує зі старою.
    \item Санітарне тестування - перевірка того, що основні функції програми відображаються коректно з новою функціональністю.
\end{enumerate} 

Тест-план - документація, що описує цілі випробувань, що мають бути досягнуті, та засоби та графік їх досягнення, організовані для координації діяльності з тестування.

Тестування на основі контрольного списку - метод тестування на основі досвіду, за допомогою якого досвідчений тестер використовує перелік високого рівня елементів, який потрібно відзначити, перевірити або запам'ятати, або набір правил або критеріїв, на основі яких має бути перевірено продукт. \cite{istqb}

