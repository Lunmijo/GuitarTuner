\section{ПЕРЕТВОРЕННЯ ФУР'Є У КОНТЕКСТІ ЦИФРОВОЇ ОБРОБКИ СИГНАЛІВ}

\subsection{Витяг з музикального теоретичного матеріалу}

\subsubsection{Види нот. Октави}

ноты бывают разной высоты и длительности. ноты могут звучать по отдельности и несколько сразу - это аккорды. ноты бывают диссонансные и консонансные (относительно друг друга).

инструменты нужно настраивать потому что плохо настроенный инструмент звучит для прошаренного слушателя абсолютно диссонансно и вообще не настраивать инструмент перед игрой богомерзко

октавы бывают разные
основные это малая, большая, первая, вторая, третья, четвертая - дальше на гитаре не взять никак ибо струна прилетит в глаз

\subsubsection{Частота нот у математичному сенсі}

с точки зрения математики частота ноты это частота колебаний волны

а звуковой сигнал это волна

Волна- это колебания, распространяющиеся в пространстве в течениие времени. (строчка копипасты)

волны бывают разные (описать какие конкретно волны бывают)

\subsubsection{Амплітуда та частота ноти}

амплитуда это наибольшее отклонение от начальной позиции

(копипаста википедии)

Амплитуда характеризует громкость звука. Частота определяет тон, высоту.

(/копипаста википедии)

\subsubsection{Обертони}

обертона определяют тембр звука

тембр это уникальное звучание 

у человека есть тембр голоса, у инструментов - тембр инструмента

в струнных музыкальных инструментах тембр получается за счет обертонов

(копипаста википедии)

обертоны это призвуки входящие в спектр (распределение значений физической величины) музыкального звука, высота обертонов выше высоты основного тона

Обертоны бывают гармоническими и негармоническими. Частоты гармонических обертонов больше частоты основного тона в 2, 3, 4, 5 и т. д. раз (кратность равна натуральному числу). Гармонические обертоны вместе с основным тоном называются гармониками и образуют натуральный звукоряд (/копипаста википедии)

сюда натыкать картиночек со спектром сигнала, обертонами и нотной записью

\subsection{Загальні положення про цифрову обробку сигналів}

\subsubsection{Аналоговий та цифровий сигнал.}

картиночки аналогового и цифрового сигнала, нужно в джупайтере отрисовать графики

https://habr.com/ru/company/yandex/blog/270765/

импульсно-кодовая модуляция

Audio bit depth



аналоговый сигнал непрерывен во времени и аналоговый сигнал природный

цифровой сигнал это дискретизированный сигнал, то есть цифровой сигнал получается если аналоговый взять в течении времени в точках

вне имеющихся точек цифровой сигнал не определен

\subsubsection{Види спотворення сигналу та способи фільтрації сигналу}

нужно погуглить про это

\subsubsection{Робота з мікрофоном у смартфоні на базі операційної системи Android}

За отримання сирих даних з мікрофону відповідає клас android.media.AudioRecord. Він записує дані у внутрішній буфер, з якого ці дані періодично потрібно забирати.

Під час ініціалізації об'єкту класу AudioRecord потрібно у конструктор передати наступні параметри:

- джерело даних;

- частота дискретизації;

- конфігурація каналів (моно чи стерео, але стерео може працювати не на всіх 
пристроях);

- формат вхідних даних, більш відомий як кодек;

- розмір внутрішнього буферу, звідки буде зчитуватись аудіопотік.

Під час створення об'єкт намагається отримати потрібні ресурси системи, і дізнатися, вдалося це йому чи ні можно за домогою методу getState(). Для отримання даних із внутрішнього буферу використовується метод read(...), що існує у декількох варіантах:

- read(byte[] audioData, int offsetInBytes, int sizeInBytes);

- read(short[] audioData, int offsetInShorts, int sizeInShorts);

- read(ByteBuffer audioBuffer, int sizeInBytes).

Параметри це:

audioData - вихідний масив

audioBuffer	вихідний буфер

offsetInBytes / offsetInShorts	індекс, з якого почнеться запис

sizeInShorts - розмір запитуваного блоку даних, у байтах для ByteBuffer та byte[], у коротких цілих для short[].

Важливим є те, що метод read(...) блокує потік до того моменту, поки не зчитає потрібну кількість байтів. А якщо у буфері байтів буде недостатньо, то метод буде очікувати, поки вони прийдуть з мікрофону. Саме тому цей метод бажано викликати у окремому потоці.

Також, для того, щоб програма мала можливість використовувати мікрофон, потрібно попросити дозволу у користувача. Починаючи з Android 7.0 дозвіл проситься під час першого запуску програми і може бути відкликаний у будь-який момент у налаштуваннях смартфону або планшету, тому потрібно перед початком зчитування даних мікрофоном переконатися у тому, що у програми є відповідний дозвіл, а якщо його немає - то попросити цього дозволу.

У файл маніфесту потрібно додати рядок:

<uses-permission android:name="android.permission.RECORD\_AUDIO" />

для того, щоб мати можливість використовувати мікрофон або простити дозволу на це.

Для того, щоб почати запис потрібно викликати метод startRecording().



\subsubsection{Види перетворення Фур'є}

для аналогового сигнала есть непрерывное фурье и оно ок только в математике потому что ой извините там интеграл на минус бесконечность до плюс бесконечности
а еще есть куча видов сверху

\subsection{Математичний аппарат перетворення Фур'є.}

погуглить и высрать

\subsubsection{Дискретизація вхідного сигналу за часом}

берем число отсчетов сигнала какое нравится, теорема найквиста-шеннона тут играет роль

\subsubsection{Виконання перетворення Фур'є для дискретизованого за часом сигналу}

как это можно сделать - погуглить

\subsubsection{Пошук найбільшої частоти серед дискретизованих точок сигналу}

по определенному правилу - погуглить - выбираем частоту и сравниваем с табличной дабы проверить является ли полученное число какой-то нотой или нет

\subsection{Багатопоточність у Java \& Android}

У даному підрозділі питання багатопоточності розглядається саме у контексті мови програмування Java, тому що саме на цій мові було написано додаток, і нас цікавлять особливості багатопоточності саме у цій мові програмування.

Багатопоточна програма має у своєму складі два або більше потоків, що виконуються одночасно та працюють разом для виконання деякої задачі. Операційна система контролює використання додатком програмних ресурсів та фізичного обладнання і дозволяє потокам програми ділится даними із центральним процесором. Java для цих цілей має клас Thread, тобто, багатопоточні Java-програми об'єктно-орієнтовані. Усі багатопоточні програми демонструють непередбачувану поведінку.

Це створює нову проблему для програмістів, особливо для тих, хто створює багатопоточні програми. \cite{carver2005modern}

Коли компонент додатку запускається за умови відсутності інших працездатних компонентів, система Android запускає новий процес Linux для додатку з одним потоком виконання. За замовчуванням, усі компоненти одного додатку працюють у одному процесі і потоці, що називається "головний потік". Якщо компонент запускається при наявності процесу для цього додатку (тому що існує інший компонент додатку), тоді компонент запускається у цьому процесі і використовує той самий потік виконання. Однак, можно організувати виконання інших компонентів додатку в окремих процесах та створювати додатковий потік для будь-якого процесу.

Система Android намагається зберігати процес додатку якумога довше, але все ж змушена видаляти старі процеси, щоб відновити пам'ять для нових чи більш важливих процесів. Система розподіляє процеси за "ієрархією важливості". Процеси бувають видимі та служебні. Процеси можуть обслугововувати потреби один одного.

Коли додаток виконує інтенсивну роботу у відповідь на дії користувача, ця одиночна модель потоку може викликати погану продуктивність, якщо додаток стврений неправильно. Тобто, якщо все відбувається у потоці користувацького інтерфейсу, виконання довгочасних операцій будуть блокувати весь користувацький інтерфейс.

Коли поток заблокований, ніякі події не можуть оброблятися, включачи події зміни відображення. З точки зору користувача додаток виглядає зависшим. Гірше за це, якщо поток користувацького інтерфейсу заблокований більше ніж 5 секунд, то з'являється повідомлення "додаток не відповідає".

Набір інструментів користувацького інтерфейсу не є потокобезпечним. Тому не варто працювати з користувацьким інтерфейсом з робочого потоку. Маніпуляції з користувацьким інтерфейсом потрібно виконувати з потоку користувацього інтерфейсу. 

Таким чином існує лише два правила однопоточної моделі Android:

1. Не блокуйте потік користувацього інтерфейсу.

2. Не звертайтесь до набору інструментів користувацького інтерфейсу Android зовні потоку користувацького інтерфейсу.

Для динамічності користувацького інтерфейсу важливо не блокувати поток користувацького інтерфейсу. Для цього важкі операції потрібно виконувати у "фонових" чи  "робоочих" потоках.

Для асінхронної роботи існує метод AsyncTask. Він виконує операції блокування у робочому потоці і після цього публікує результати у потоці користувацього інтерфейсу без необхідності самостійно обробляти потоки чи обробники. \cite{androiddevelopers}

\subsubsection{Способи вирішення конфлікту між потоками}

У деяких випадках реалізовані методи можуть викликатися із декількох потоків і, відповідно, мають бути написани із збереженням потокобезпечності.

Система Android пропонує механізм взаємодії процесів (IPC) із допомогою видаленого виклику процедури (RPC), під час якого метод викликається дією чи іншим компонентом додатку, але виконується видаленно (у іншому процесі) із поверненням усіх результатів викликаючему компоненту. Це викликає розділення визову методу та його даних до рівня, зрозумілого операційній системі, передачу його з локального процесу та адресного простору видаленому процесу і адресному простору, після чого повторну збірку та поновлення виклику. Після цього повертаємі значення передаються у зворотньому напрямку. 

Для виконання IPC додаток має бути прив'язаний до служби за допомогою методу bindService(). \cite{androiddevelopers}

Стан гонки, або конкуренція - це помилка проектування багатопоточної системи чи додатку, під час якої стан системи залежить від того, у якому порядку виконуються частини коду. У научному середовищі цей термін прийнято називати невизначеність паралелізму. \cite{jonathan2005linux}

Стан гонки може виникнути, якщо два потоки обробляють одну інформацію і це ніяк не було проконтрольовано розробником, як це відбувається у додатку гітарного тюнеру, де потік користувацького інтерфейсу отримує дані зі змінної, що контролюється іншим потоком.



